# Use `std::atomic<uint64_t>` message counter to synchronize 1 Writer with multiple Readers

## Status

What is the status, such as proposed, accepted, rejected, deprecated, superseded, etc.?
[ ] proposed, [X] accepted, [ ] rejected, [ ] deprecated, [ ] superseded

## Context

Writer writes a message into the circular buffer and increments the atomic message counter. Readers wait for the atomic message counter to increment before reading the next message from the circular buffer.

## Decision

Use `std::atomic<uint64_t>`.
If you can achieve 1ns message write latency, you would overflow the 64bit message counter after ~584.9 years.

`2^64 ns / 10^9 / 60 / 60 / 24 / 365 = 584.942417355 years`

## Consequences

Lock-free message queue, lock-free Writer and Readers synchronization.
